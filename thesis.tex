\documentclass[12pt,a4paper]{article}

\usepackage{fontspec}
\usepackage{polyglossia}
\usepackage[left=2.5cm,top=2.5cm,right=2.5cm,bottom=2.5cm,nohead]{geometry}
\usepackage{setspace}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{color}
\usepackage{float}
\usepackage{courier}
\usepackage{bold-extra}
\usepackage{fix-cm}
\usepackage{alltt}
\usepackage{indentfirst}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{url}

\defaultfontfeatures{Mapping=tex-text}

\setmainfont{Liberation Serif}
\setsansfont{Liberation Sans}
\setmonofont{Liberation Mono}
\setmainlanguage{ukrainian}
\setotherlanguage{english}



\graphicspath{{./images/}}

\setstretch{1.1}

\definecolor{javared}{rgb}{0.6,0,0}
\lstdefinelanguage{Smalltalk}{ 
  morekeywords={true,false,self,super,nil}, 
  sensitive=true, 
  morecomment=[s]{"}{"}, 
  morestring=[d]', 
} 
 
\lstset{
	basicstyle=\footnotesize\ttfamily,
	showspaces=false,
	stringstyle=\color{javared},
	showstringspaces=false,
	xleftmargin=	.6cm
}

\begin{document}
\pretolerance=-1
\tolerance=2300

\thispagestyle{empty}
\setlength{\parindent}{1.5cm}
\fontsize{14pt}{6mm}\selectfont

\begin{center}
  Міністерство освіти і науки, молоді та спорту України
  
  Львівський національний університет імені Івана Франка

  Факультет прикладної математики та інформатики
\end{center}

\vspace{1cm}

\begin{flushright}
  Кафедра програмування
\end{flushright}

\vspace{4cm}

\begin{center}
  {\bfseries\Large Розширення функціональності моделі FAMIX для побудови абстрактних дерев коду Java-- та Smalltalk--програм}
\end{center}

\vspace{2cm}

\begin{small}
\begin{flushleft}\leftskip8.5cm
  Магістерська робота студента групи ПМІ-51м\\
  Тимчука Ю.А.\linebreak
  
  Науковий керівник:\\
  доц. Рикалюк Р.Є.
\end{flushleft}
\end{small}

\vspace{5cm}

\begin{center}
  Львів - 2013 
\end{center}

\clearpage



\setstretch{1.5}
\fontsize{14pt}{6mm}\selectfont

\newcommand{\vect}[1]{(#1_1,#1_2,\dots,#1_n)}

\thispagestyle{empty}
\tableofcontents
\clearpage
\pagenumbering{arabic}

\section{Вступ}

Мета--моделювання було створено, щоб дозволити розглядати програми на більш високому рівні абстракції, ніж це дозволяють поточні мови програмування. Основна ідея полягає в тому, що хтось визначає високорівневу модель рішення, описує, як перетворити це рішення в програму для даної мови, а потім автоматично генерує вихідний код. В ідеалі такий же підхід дозволяє взяти існуючу програму, автоматично отримати абстрактну модель з неї, вручну розширити або поліпшити модель і згенерувати нову програму, можливо, на новій мові програмування (round-trip engineering). Такий підхід був би дуже цікавим для організацій, що мають програми написані на старих технологіях (наприклад, Cobol) і хочуть перенести їх на більш сучасні (наприклад, Java). Команда RMoD вже має інструменти, які можуть приймати програми (написані на C, Java, Smalltalk, і т.д.) в якості вхідних даних і продукувати з них моделі.

Тим не менш, чорт сидить в деталях, в даному випадку, для зворотньої розробки існуючої програми, щоб мати можливість відновити її потім, треба тримати багато деталей по цю програму. Ця потреба, звичайно, не сумісна з ідеєю абстрагування моделі цієї програми. Тому потрібно, бути в змозі створити абстрактну модель програми, але, в той же час, створити дуже детальну модель тієї ж програми і таким чином, мати можливість працювати на двох рівнях абстракції одночасно.

Як приклад можна розглянути дві об'єктно-орієнтовані мови програмування: Java та Smalltalk. Обидві мають подібну структуру: простори імен, класи, поля та методи класів. Але у мові Smalltalk відсутні інструкції галуження та циклу, які, безперечно, відіграють важливу роль в Java коді. З другого боку код Java не має нічого аналогічного до блоків у мові Smalltalk, які дозволяють реалізовувати галуження та цикли за допомогою методів.

Метою цієї магістерської роботи є розширення вже існуючої мета--моделі FAMIX шляхом додавання до неї компонент абстрактних синтаксичних дерев мов програмування Java та Smalltalk.

\subsection{Перспективи використання}
Абстрактні синтаксичні дерева зазвичай використовуються при компіляції, але дана мета--модель спрамована на візуалізацію вихідного коду, і таким чином надання інстументів для кращого розуміння та маніпуляції над ним.

Маючи в своєму розпорядженні універсальне дерево, яке можна буде розширявати для різних мов, слідуючи простим правилам, можна розроляти алгоритми, які, відповідно. будуть працювати для всіх розчирень дерева. Таким чином можна буде зробити інстумент для моделювання прогам написаних практично будь-якій мові програмування вез значних затрат ресурсів. Серед можливих алгоритмів можна виділити:

\textbf{Symbol resolution}: сутність змінної в абстрактних синтаксичних деревах несе лише інформацію про назву змінної, цього доволі мало для аналізу вихідного коду. Одинаковий ідентифікатор може зустрічатись в різних місцях програми, але відноситись до різних змінних.

\textbf{Інтерфейс взаємодії}: модель являє собою лише пов'язані між собою сутності з параметрами. Для полегшення роботи з моделлю потрібно розробити первний інтерфейс взаємоді, наприклад: графічну оболонку, мову запитів.

\textbf{Перевірка правил}: маючи модель вихідного коду можна реалізувати перевірку деякий правил, щоб виявити „поганий“ код, як наприклад: \lstinline$if (false) {...}$.

\textbf{Генерація коду з моделі}: якщо можна було б генерувати код програми з наявної моделі, то це б можна було використати для рефакторинку програм шляхом взаємодії з графом моделі у графічному інтерфейсі. Можливо аналогічний підхід можна було б завтосовувати для побудови програм.

\textbf{Перетворення між мовами}: маючи в наявності реалізацію вищезазначеного функціоналу можна було б розробити перетворення коду з однієї мови в іншу. Звичайно, неможливо написати алгоритм, який буде генерувати ідеальний конд на новій мові програмування, але навіть можливість згрубша перевести програмне забезпечення, яке складається з мільйонів радків коду було б корисною можливістю.

\clearpage

\section{Moose}

В рамках цієї роботи використовується платформа з відкритим кодом Moose\cite{moose}, яка призначенна для аналізу систем програмного забезпечення та даних в цілому. Ця платформа написана на мові програмування Smalltalk та інтегрується безпосередньо в середовище Pharo. Ядро Moose надає можливість збереження та взаємодії із сутномсями моделей. Для цього використовуються три базові класи: \emph{Entity}, \emph{Group} та \emph{Model}.

Клас Entity(сутність) є базовим представленням сутності у моделі. Тому передбачено, що конкретні сутності специфічних мета--моделей будуть наслідуватись саме від цього класу. Entity надає два загальні сервіси. Перший - це зв'язок з моделлю до якої належить дана сутність. Це веде до циклічної залежності між моделлю та сутністю, але з одного боку така реалізація нікому не заважає, а з другого - дозволяє легко формувати запити, які потребують більшу кількість інформації аніж дана сутність може надати. Другою важливою особливістю Entity є механізм управління станами і розширенням, який досягається за рахунок ієрархії EntityState. Ця їєрархія надає словник, в якому можна зберігати дані про сутність, зокрема кешувати дані отримані підчас виконання запитів.

Клас Group(група) - це сутність, яка відображає колекцію сутностей. Наприклад, у нас може бути група сутностей класів, чи група сутностей методів. Групи є важливою абстракцією, особливо для виконання запитів та користувацького інтерфейсу.

Клас Model(модель) по своїй суті є сукупністю сутностей та їх внутрішніх зв'язків для вибраної системи. Це спеціальний підвид групи.

Moose використовує сім'ю мета-моделей під назвою FAMIX. Вони можуть бути використані для представлення моделей пов'язаних з різними аспектами систем програмного забезпечення. Ці мета-моделі зазвичай спрамовані на полегшення аналізу,  і надають багатий API для здійснення запитів та навігації. Ядро FAMIX складається з узагальненої мета-моделі, яка може відобразити багато об'єктно--орієнтованих та процедурних мов. 

\clearpage

\section{Основні ідеї AST}



Абстрактне синтаксичне дерево зазвичай використовується компілятором як основа для генерування байт--коду. В нашому ж випадку модель абстрактного ситтаксичоно дерева має містити якомога більше кількітьсь інформації для того, щоб дозволити нам проводити аналіз різного типу на її основі. З цією ж метою мета--модель, яку ми розробляємо буде мкасимально зв'язаною з існуючою мета--моделлю.

\textbf{Вираз (Expression)} - це частина коду, яка має певне значення. Це може бути літерал, змінна, виклик функції (чи методу). Вираз може бути присвоїним змінній чи переданим як аргумент.

Виконавче тіло методу складається з \textbf{речень (Statement)}. Кожне речення являє собою повноцінну виконавчу ланку. Яскравими прикладами речень є інстукція галуження „if“, інструкції циклів, або ж речення, яке вказує на повернення з методу. Також часто зустрічаються речення які просто містять вираз, наприклад:
\begin{lstlisting}[language=Java]
System.out.printl("Hello world");
\end{lstlisting}

Часто важко побачити різницю між виразами та реченнями. Перш за все збивають речення які не містять нічого іншого крім виразу. Наприклад
\begin{lstlisting}[language=Smalltalk]
5 factorial
\end{lstlisting}
це вираз. Ми його можем передати як параметер повідомлення або ж відправити повідомлення йому самому:
\begin{lstlisting}[language=Smalltalk]
'Factorial of 5: ', 5 factorial asString
\end{lstlisting}
Наступний приклад є реченням:
\begin{lstlisting}[language=Smalltalk]
5 factorial.
\end{lstlisting}
В смолтоці крапки використовуються як розділювачі для реченнь. Даний приклад доволі концептуальний, але головне його покликання --- показати, що речення --- це сутності на найвищому рівні виконавчого коду. І не зважаючи на те, що деякі речення можуть складатись з лише одного виразу --- це всеодно речення і вони є абсолютно відмінними від сутностей.

З другого боку різні мови мають різні правила. Наприклад в смолтоку присвоєння є виразом, тому ми можемо написати:
\begin{lstlisting}[language=Smalltalk]
list add: x := 5 factorial
\end{lstlisting}
цей код обчислить $5!$ присвоїть його змінній $x$ а потім додасть ці значення до списку. В мові програмування \emph{Basic} присвоєння є реченням, це також часто призводить до непорозумінь між термінами.

Давайте розглянемо приклад:
\begin{lstlisting}[language=Smalltalk]
middleOf: a and: b
    | sum |
    sum := a + b.
    ^ sum / 2
\end{lstlisting}
Перші два рядки відносяться до оголошення методу та тимчасових змінних, тому зараз можемо їх опустити. У даному прикладі присутні два \emph{речення}:
\begin{enumerate}
	\item \lstinline$sum := a + b$
	\item \lstinline$^ sum / 2$
\end{enumerate}
А також близько пів--дюжини \emph{виразів}: \lstinline$sum := a + b$, \lstinline$sum$, \lstinline$a + b$, \lstinline$a$, \lstinline$b$, \lstinline$sum / 2$, \lstinline$2$.

Не зважаючи на те, що я розробляю окремі моделі для кожної з мов, за основу було вибрано ідею, яка передбачає стандартні правила для всіх моделей. Цю ідею можна сформулювати наступним чином:
\begin{enumerate}
  \item Виконавча частина функції(методу) є послідовністю речень.
  \item Речення може містити вирази або ж виконавчі блоки.
  \item Виразом є сутність, яка має значення.
\end{enumerate}
Тому в наступних моделях у нас будуть присутні базові типи \emph{речення} та \emph{вираз}, при чому без будь-яких безпосередніх зв'язків. Звичайно, в їхні наслідники можуть залежати одне від одного, але на найвищому рівні ми таких обмежень не накладаєм.

В якості узагальнення всіх посилання на сутності задопомогою їхнього ім'я використаємо \textbf{іменовану сутність (Named Entity)}. Прикладом може бути використання будь-якої змінної для присвоєння їй значення чи використання значення на яке вона вказує, або ж назва класу метод якого буде викликатись. Ця сутність буде зв'язана з іменованою сутністю FAMIX, яка в свою чергу може бути локальною чи глобальною змінною, параметром, змінною класу, неявною змінною, або ж класом.

\textbf{Cутність з поведінкою (Behavioural Entity)} - це сутність, яка має в собі певний код, який виконується --- поведінку. Наприклад методи, функції, замикання та лямбда--функції є такими сутностями. Ця сутність має набір \emph{речень}, а також два набори \emph{іменованих сутностей} в якості параметрів та локальних змінних. \emph{Cутність з поведінкою} буде слугувати коренем для нашого дерева. Логічним розширенням буде \textbf{іменована сутність з поведінкою (Named Behavioural Entity)}, так як методи та функції мають ім'я чи селектор за яким їх можна ідентифікувати. \emph{Іменована сутність з поведінкою} в свою чергу буде зв'язана з іменованою сутністю FAMIX, так як остання передбачає в собі наявність селектора.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.95\textwidth]{GeneralASTClassDiagram}
  \caption{Базова структура FAST\label{genFast}}
\end{figure}

На рис.~\ref{genFast} показано діаграму основи моделі. Префікс \textbf{FAST} - це назва моделі, означає він Famix AST.


\clearpage

\section{Мета--модель абстрактного дерева Smalltalk}

Діаграма класів моделі абстрактного синтаксичного дерева смолтоку рис.~\ref{smtFast}.

\begin{figure}[h]
  \centering
    \includegraphics[width=0.95\textwidth]{SmalltalkASTClassDiagram}
  \caption{Діаграма FAST для смолтоку\label{smtFast}}
\end{figure}

\clearpage

\addcontentsline{toc}{section}{Література}
\begin{thebibliography}{9}

\bibitem{moose}Tudor Girba, \emph{The Moose Book} [Електронний ресурс],
    2011. Режим доступу:
    \url{http://www.themoosebook.org/book/table-of-contents}

\bibitem{mse-famix}S.Ducasse, J.Laval, N.Anquetil, A.Cavalcante-Hora, U.Bhatti, \emph{MSE and FAMIX 3.0: an Interexchange Format and Source Code Model Family} [Електронний ресурс], 2011. Режим доступу:
    \url{http://rmod.lille.inria.fr/archives/reports/Duca11c-Cutter-deliverable22-MSE-FAMIX30.pdf}
    
\bibitem{astm-spec}Object Management Group, Inc. \emph{Abstract Syntax Tree Metamodel (ASTM) Specification} [Електронний ресурс], 2008. Режим доступу:
    \url{http://www.omg.org/spec/ASTM/1.0/Beta1/PDF}

\end{thebibliography}

\end{document}
