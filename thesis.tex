\documentclass[12pt,a4paper]{article}

\usepackage{fontspec}
\usepackage{polyglossia}
\usepackage[left=2.5cm,top=2.5cm,right=2.5cm,bottom=2.5cm,nohead]{geometry}
\usepackage{setspace}
\usepackage{listings}
\usepackage{color}
\usepackage{float}
\usepackage{courier}
\usepackage{bold-extra}
\usepackage{fix-cm}
\usepackage{alltt}
\usepackage{indentfirst}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{url}

\setmainfont{Times New Roman}
\setmainlanguage{ukrainian}
\setotherlanguage{english}
\renewcommand\UrlFont{\ttfamilylatin}

\setstretch{1.1}

\begin{document}
\pretolerance=-1
\tolerance=2300

\thispagestyle{empty}
\setlength{\parindent}{1.5cm}
\fontsize{14pt}{6mm}\selectfont

\begin{center}
  Міністерство освіти і науки, молоді та спорту України
  
  Львівський національний університет імені Івана Франка

  Факультет прикладної математики та інформатики
\end{center}

\vspace{1cm}

\begin{flushright}
  Кафедра програмування
\end{flushright}

\vspace{4cm}

\begin{center}
  {\bfseries\Large Розширення функціональності моделі FAMIX для побудови абстрактних дерев коду Java- та Smalltalk-програм}
\end{center}

\vspace{2cm}

\begin{small}
\begin{flushleft}\leftskip8.5cm
  Магістерська робота студента групи ПМІ-51м\\
  Тимчука Ю.А.\linebreak
  
  Науковий керівник:\\
  доц. Рикалюк Р.Є.
\end{flushleft}
\end{small}

\vspace{5cm}

\begin{center}
  Львів - 2013 
\end{center}

\clearpage



\setstretch{1.5}
\fontsize{14pt}{6mm}\selectfont

\newcommand{\vect}[1]{(#1_1,#1_2,\dots,#1_n)}

\thispagestyle{empty}
\tableofcontents
\clearpage
\pagenumbering{arabic}

\section{Вступ}

Метамоделювання було створено, щоб дозволити розглядати програми на більш високому рівні абстракції, ніж це дозволяють поточні мови програмування. Основна ідея полягає в тому, що хтось визначає високорівневу модель рішення, описує, як перетворити це рішення в програму для даної мови, а потім автоматично генерує вихідний код. В ідеалі такий же підхід дозволяє взяти існуючу програму, автоматично отримати абстрактну модель з неї, вручну розширити або поліпшити модель і згенерувати нову програму, можливо, на новій мові програмування (round-trip engineering). Такий підхід був би дуже цікавим для організацій, що мають програми написані на старих технологіях (наприклад, Cobol) і хочуть перенести їх на більш сучасні (наприклад, Java). Команда RMod вже має інструменти, які можуть приймати програми (написані на C, Java, Smalltalk, і т.д.) в якості вхідних даних і продукувати з них метамоделі.

Тим не менш, чорт сидить в деталях, в даному випадку, для зворотньої розробки існуючої програми, щоб мати можливість відновити її потім, треба тримати багато деталей по цю програму. Ця потреба, звичайно, не сумісна з ідеєю абстрагування моделі цієї програми. Тому потрібно, бути в змозі створити абстрактну модель програми, але, в той же час, створити дуже детальну модель тієї ж програми і таким чином, мати можливість працювати на двох рівнях абстракції одночасно.

Як приклад можна розглянути дві об'єктно-орієнтовані мови програмування: Java та Smalltalk. Обидві мають подібну структуру: простори імен, класи, поля та методи класів. Але у мові Smalltalk відсутні інструкції галуження та циклу, які, безперечно, відіграють важливу роль в Java коді. З другого боку код Java не має нічого аналогічного до блоків у мові Smalltalk, які дозволяють реалізовувати галуження та цикли за допомогою методів.

Метою цієї магістерської роботи є розширення вже існуючої метамоделі FAMIX шляхом додавання до неї компонент абстрактних синтаксичних дерев мов програмування Java та Smalltalk.

\clearpage

\section{Moose}

В рамках цієї роботи використовується платформа з відкритим кодом Moose\cite{moose}, яка призначенна для аналізу систем програмного забезпечення та даних в цілому. Ця платформа написана на мові програмування Smalltalk та інтегрується безпосередньо в середовище Pharo. Ядро Moose надає можливість збереження та взаємодії із сутномсями моделей. Для цього використовуються три базові класи: \emph{Entity}, \emph{Group} та \emph{Model}.

Клас Entity(сутність) є базовим представленням сутності у моделі. Тому передбачено, що конкретні сутності специфічних метамоделей будуть наслідуватись саме від цього класу. Entity надає два загальні сервіси. Перший - це зв'язок з моделлю до якої належить дана сутність. Це веде до циклічної залежності між моделлю та сутністю, але з одного боку така реалізація нікому не заважає, а з другого - дозволяє легко формувати запити, які потребують більшу кількість інформації аніж дана сутність може надати. Другою важливою особливістю Entity є механізм управління станами і розширенням, який досягається за рахунок ієрархії EntityState. Ця їєрархія надає словник, в якому можна зберігати дані про сутність, зокрема кешувати дані отримані підчас виконання запитів.

Клас Group(група) - це сутність, яка відображає колекцію сутностей. Наприклад, у нас може бути група сутностей класів, чи група сутностей методів. Групи є важливою абстракцією, особливо для виконання запитів та користувацького інтерфейсу.

Клас Model(модель) по своїй суті є сукупністю сутностей та їх внутрішніх зв'язків для вибраної системи. Це спеціальний підвид групи.

Moose використовує сім'ю мета-моделей під назвою FAMIX. Вони можуть бути використані для представлення моделей пов'язаних з різними аспектами систем програмного забезпечення. Ці мета-моделі зазвичай спрамовані на полегшення аналізу,  і надають багатий API для здійснення запитів та навігації. Ядро FAMIX складається з узагальненої мета-моделі, яка може відобразити багато об'єктно-орієнтованих та процедурних мов.

\clearpage

\addcontentsline{toc}{section}{Література}
\begin{thebibliography}{9}

\bibitem{moose}Tudor Girba, \emph{The Moose Book} [Електронний ресурс],
    2011. Режим доступу:
    \url{http://www.themoosebook.org/book/table-of-contents}

\bibitem{mse-famix}S.Ducasse, J.Laval, N.Anquetil, A.Cavalcante-Hora, U.Bhatti, \emph{MSE and FAMIX 3.0: an Interexchange Format and Source Code Model Family} [Електронний ресурс], 2011. Режим доступу:
    \url{http://rmod.lille.inria.fr/archives/reports/Duca11c-Cutter-deliverable22-MSE-FAMIX30.pdf}

\end{thebibliography}

\end{document}
